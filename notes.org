#+OPTIONS: toc:nil

* To-Do
- [X] Get unit tests running inside Emacs.
- [X] Get gorename tool working (again, inside of Emacs)
- [X] Have another look at how things get exported.  i.e. the client apps should only create an assembler fro components, which itself creates a lexer and a parser, but doesn't allow these to be seen in interacted with.
- [X] Take notes on the two vids on error handling (article?), and nil.
- [X] Take notes on the best way to signal errors when communicating via channels.
- [X] Check the error handling so far - the components package should NOT call os.Halt() or log.Fatal().  Remember that in Go, errors are values, so just pass them back or collect them and return a wrapped error or anything, really.
- [X] test error reporting
- [X] test cleanup of partially written file
- [X] Get flib onto Github
- [X] Update parser to only return a channel of string
- [X] get the parser running in its own go routine
- [ ] take notes on the built-in profiling / benchmarking
- [X] performance - write parser tests/benchmarks
- [ ] performance - get a profile
- [ ] Ask the N2T folks re copyright - is it ok for me to include the Pong.asm file (including original attribution) in my repository?
- [ ] performance - try streaming the input file instead of reading all at once (more pipelining).  Can I benchmark this?  I means having a 'unit' test that relies on an external file.  Meh, why not?  Check with N2T folks first.
- [ ] then figure out locking around the error!  Both this routine and anything calling it, need to access the error field of the parser struct.  Feck.  Will need a method to return the error instead of accessing it directly.
- [ ] performance - ask on StackExchange if closures are the best way to handle the generics work around with state functions
- [ ] write some error tests, pretty sure I haven't thought of all edge cases yet
- [ ] Get this org file to export the README section every time it's saved.

* Readme
A collection of tools for the [[http://nand2tetris.org/][Nand2Tetris project.]]

** Components
Everything needed for a basic assembler and compiler.  A Lexer (assembly -> tokens), parser (tokens -> machine code) and a compiler (watch this space, will have own lexer/parser).

I'm going with a fully fledged lexer/parser for the initial Assembler project so that it can be reused in the compiler project.  The Lexer is blatantly ripped from [[https://www.youtube.com/watch?v=HxaD_trXwRE][Rob Pike's talk here]].

It's totally overkill for the assembler, (which is really just an exercise in substitution, and would be easy enough to do with regular expressions (eugh)), but I figure this will be more challenging and a good way to get my head around Go (plus partial reuse in the compiler project).

/Postscript:/ It turns out that I'm a masochist.  This WAS a good way to learn a new language, but maybe next time don't also learn how to write something like a lexer (which I'm still not happy about, it doesn't feel 'clean' in the same way that the parser does) at the same time too.

** Assembler
Basic assembler that maps symbols/tokens to machine instructions.  Output is a text file with "binary" values written out as string.  Internally they're all going to be represented by 16 bit constants that are then OR'd together and converted to a string representation at the end.  This is because it sounds more 'program-y' but mainly because I cannot bring myself to write this using string concatenation (plus it's good practice as I'm learning Go at the same time).

Bonus points: Handles both Unix and Windows line endings, and has a warning for redundant A-Instructions (i.e. @123 followed by @456 is redundant, @123 will have no effect).

Still to do - tidy up Lexer, and in fact make it dumber.  Right now it's doing a fair bit or error checking that could probably be done more easily in the parser, making the lexer code cleaner.

** Compiler
TBD
* Lexer (Assembler)
- [X] Think about only returning an EOL if have already send an actual instruction?  Flag when encounter instruction, clear when encounter an EOL, and only sed an EOL if the flag is set.
- [X] Figure out why empty lines are not being counted.
- [X] See if can get Git to ignore executable files?
- [X] swear a fuck of a lot more because I forgot that Unix and Windows use different line-ending characters.
- [X] Figure out why the line numbers are not being recorded correctly.
- [X] Fix Windows issues (hah!)
- [X] If /really/ want to, figure out why some test scenarios have an EOL before teh EOF, while others don't.
- [ ] General tidy (endOfCode can be simplified, i.e. only init should emit EOF)
* Parser (Assembler)
- [X] Set up constants (in map literal) for machine instructions
- [X] first loop - go through collecting symbols and adding to symbol table
- [X] generate numbers for the symbols
- [X] BUG! - symbol table: default for variable is a legit instruction memory address.
- [X] second loop, output ints to a file
- [X] test
- [X] can the parser be simplified?  just range over lexemes, or-ing results until EOL?
- [X] draw down the data flow, write up what's happening, and then watch another couple vids on error handling in Golang - I definitely feel that I'm making it more complex than I need to.
- [X] Warning - can now warn about redundant '@' expressions


