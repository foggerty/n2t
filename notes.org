#+OPTIONS: toc:nil

* To-Do
- [X] Get unit tests running inside Emacs.
- [X] Get gorename tool working (again, inside of Emacs)
- [X] Have another look at how things get exported.  i.e. the client apps should only create an assembler fro components, which itself creates a lexer and a parser, but doesn't allow these to be seen in interacted with.
- [X] Take notes on the two vids on error handling (article?), and nil.
- [X] Take notes on the best way to signal errors when communicating via channels.
- [ ] Read up (and take notes) on how the select statement works with channels.  NOTE: Select != Switch, and I'm not sure how I managed to conflate the two in my head.  
- [ ] Check the error handling so far - the components package should NOT call os.Halt() or log.Fatal().  Remember that in Go, errors are values, so just pass them back or collect them and return a wrapped error or anything, really.
- [ ] Ensure that the documentation generated for the ~components~ package is showing up in godoc!
- [ ] Get this org file to export the README section every time it's saved.

* Readme
A collection of tools for the [[http://nand2tetris.org/][Nand2Tetris project.]]

** Components
Everything needed for a basic assembler and compiler.  A Lexer (assembly -> tokens), parser (tokens -> machine code) and a compiler (watch this space, will have own lexer/parser).

I'm going with a fully fledged lexer/parser for the initial Assembler project so that it can be reused in the compiler project.  The Lexer is blatantly ripped from [[https://www.youtube.com/watch?v=HxaD_trXwRE][Rob Pike's talk here]].

It's totally overkill for the assembler, (which is really just an exercise in substitution, and would be easy enough to do with regular expressions (eugh)), but I figure this will be more challenging and a good way to get my head around Go (plus partial reuse in the compiler project).

** Assembler
Basic assembler that maps symbols/tokens to machine instructions.  Output is a text file with "binary" values written out as string.  Internally they're all going to be represented by 16 bit constants that are then OR'd together and converted to a string representation at the end.  This is because it sounds more 'program-y' but mainly because I cannot bring myself to write this using string concatenation (plus it's good practice as I'm learning Go at the same time).

** Compiler
TBD
* Lexer (Assembler)
- [X] Think about only returning an EOL if have already send an actual instruction?  Flag when encounter instruction, clear when encounter an EOL, and only sed an EOL if the flag is set.
- [X] Figure out why empty lines are not being counted.
- [X] See if can get Git to ignore executable files?
- [X] swear a fuck of a lot more because I forgot that Unix and Windows use different line-ending characters.
- [X] Figure out why the line numbers are not being recorded correctly.
- [X] Fix Windows issues (hah!)
- [X] If /really/ want to, figure out why some test scenarios have an EOL before teh EOF, while others don't.
- [ ] General tidy (endOfCode can be simplified, i.e. only init should emit EOF)
* Parser (Assembler)
- [X] Set up constants (in map literal) for machine instructions
- [X] first loop - go through collecting symbols and adding to symbol table
- [X] generate numbers for the symbols
- [X] BUG! - symbol table: default for variable is a legit instruction memory address.
- [ ] second loop, output ints to a file
- [ ] test
- [ ] then add error handling (or rewrite!) once I get a good idea of how this all fits together.  i.e. error if an AInstruction if < 0 or > 2^15.  Do this during the symbol building phase, so that writing asm, can just assume that everything is ok.


